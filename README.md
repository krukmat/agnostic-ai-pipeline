# Loop Release Workflow ‚Äì AGNOSTIC AI PIPELINE üèóÔ∏è

**Deliver finished products through repeatable BA ‚Üí Architect ‚Üí Dev ‚Üí QA release loops.**

## Project Overview

- **Purpose** ‚Äì Automate the product-development loop from concept intake to QA validation, producing code, tests, and planning artifacts ready for release.
- **Roles** ‚Äì Business Analyst, Product Owner, Architect, Developer, QA, and Orchestrator collaborate sequentially (classic mode) or via services (A2A mode).
- **Artifacts** ‚Äì Planning YAMLs (`requirements.yaml`, `stories.yaml`, etc.), generated code/tests under `project/`, QA reports in `artifacts/qa/`.
- **Workflows** ‚Äì Use `make iteration`/`make loop` for one-shot runs, or start individual CLIs to execute or debug each role independently.

```mermaid
flowchart LR
    Concept[Business Concept] --> BA[Business Analyst]
    BA --> PO[Product Owner]
    PO --> ARCH[Architect]
    ARCH --> DEV[Developer]
    DEV --> QA[QA]
    QA --> Snapshot[Snapshot & Release Artifacts]
```

### A2A-Enabled Pipeline at a Glance

This repository adopts the Agent-to-Agent (A2A) protocol so every pipeline role can run as an independent HTTP service. Each role publishes an Agent Card (capabilities, skills, auth) and collaborates through JSON-RPC calls orchestrated by the pipeline. You can:

- Trigger the traditional loop with `make iteration` (BA‚ÜíPO‚ÜíArchitect‚ÜíDev‚ÜíQA in one command).
- Launch the A2A mesh (`python scripts/run_<role>.py serve`) and coordinate roles dynamically via the Orchestrator service or the `A2AClient` helpers.

Agent endpoints, ports, and skills live in `config/a2a_agents.yaml`, enabling you to deploy agents separately, swap implementations, or integrate external services without touching the orchestration core.

```mermaid
flowchart LR
    subgraph Services
        BA[BA Agent]
        PO[PO Agent]
        ARCH[Architect Agent]
        DEV[Dev Agent]
        QA[QA Agent]
    end
    Orchestrator[Orchestrator Service] --> BA
    Orchestrator --> PO
    Orchestrator --> ARCH
    Orchestrator --> DEV
    Orchestrator --> QA
    BA -.Agent Card/.-> Registry[(config/a2a_agents.yaml)]
    PO -.-> Registry
    ARCH -.-> Registry
    DEV -.-> Registry
    QA -.-> Registry
```

#### Classic vs. A2A Modes

- **Classic (‚Äúmonolithic‚Äù) mode** ‚Äì Run `make iteration`, `make loop`, or the individual role scripts without `serve`. Everything executes sequentially inside one process. Use this mode for quick iterations on a single machine when you don‚Äôt need distributed orchestration.
- **A2A (‚Äúservice mesh‚Äù) mode** ‚Äì Start each role with `python scripts/run_<role>.py serve`. Agents expose HTTP endpoints and can be orchestrated remotely (`A2AClient`, Orchestrator skill, or external tools). Choose this mode when you want independent scaling, easier substitution of agents, or when multiple teams/services must collaborate over a stable protocol.

Both modes share the same business logic; switching between them only changes how the roles are invoked and coordinated.

### Theoretical Context

The [A2A specification](https://a2a-protocol.org/latest/) defines three pillars that we apply in this repo:

1. **Agent discovery via Agent Cards** ‚Äì Every service exposes `/.well-known/agent-card.json` describing its identity, authentication requirements, skills (input/output modes, examples), and endpoint. In our project these cards are generated by the FastAPI layer (`a2a/server.py`) and parameterised via `config/a2a_agents.yaml`.
2. **Standardised messaging over JSON-RPC 2.0** ‚Äì Agents invoke each other through the `message/send` method, embedding the task payload (and optional streaming/artifact metadata). The reusable `create_agent_app()` dispatcher handles this contract, while `A2AClient` wraps the HTTP calls to keep orchestrator code concise.
3. **Task lifecycle & artifact sharing** ‚Äì A2A models work items as tasks with clear states and optional artifacts. Each role handler (BA, PO, Architect, Dev, QA, Orchestrator) returns structured JSON containing both status and pointers to generated files (e.g., `planning/requirements.yaml`). The Orchestrator skill composes these results to deliver a full release increment.

Together, these concepts allow the pipeline to remain modular: each agent can evolve independently, yet the overall system stays interoperable and discoverable under one standard.

---

## Why Loop Releases Matter

- Wraps the entire multi-agent pipeline into a single iteration artifact.
- Guarantees every release includes stories, code, tests, QA evidence, and reproducible state.
- Enables strict or exploratory runs (QA strict vs relaxed) while preserving audit trails.
- Simple to operate (`make iteration ...`), powerful enough for enterprise backlogs, and extensible to any professional or hobby setup.

---

## Example Release Scenarios

| Scenario | Goal | Command |
| -------- | ---- | ------- |
| **CoffeeClub Inventory & Ordering** | Strict inventory/ordering flow with real-time dashboards | `make iteration CONCEPT="CoffeeClub Inventory & Ordering" LOOPS=2 ALLOW_NO_TESTS=0` |
| **E-commerce MVP** | Quick prototype with relaxed QA to explore UI variants | `make iteration CONCEPT="Retail MVP" LOOPS=1 ALLOW_NO_TESTS=1 ITERATION_NAME="explore-retail"` |
| **Mobile Companion App** | Leverage a React Native skeleton added to `project-defaults/` | `make iteration CONCEPT="Courier Mobile Companion" LOOPS=2 SKIP_BA=0` |
| **API Hardening Sprint** | Re-run architect/dev/qa using existing requirements | `make iteration CONCEPT="API Hardening" LOOPS=3 SKIP_BA=1` |
| **Localized Content Update** | Switch Dev role to Codex CLI for domain-specific models | `make set-role role=dev provider=codex_cli model="codex-local"`<br>`make iteration CONCEPT="Localized Content Refresh" LOOPS=2` |

These examples illustrate how loop releases stay **simple (single make command)**, **powerful (full BA‚ÜíQA automation)**, and **extensible (drop in new skeletons or providers)** across professional or amateur environments.

---

## 1. Loop Release at a Glance

```bash
make iteration CONCEPT="Login MVP" LOOPS=2 ITERATION_NAME="release-2025Q1"
```

- **CONCEPT** ‚Äì Plain-text business goal consumed by BA and Architect.
- **LOOPS** ‚Äì Number of Dev‚ÜíQA passes in the iteration (defaults to 1).
- **ITERATION_NAME** ‚Äì Human-readable label for snapshots under `artifacts/iterations/`.
- **ALLOW_NO_TESTS** ‚Äì Set to `0` for strict QA, `1` for exploratory prototyping.
- **SKIP_BA / SKIP_PLAN** ‚Äì Reuse existing requirements/stories without re-running those roles.

Each call orchestrates BA ‚Üí Architect ‚Üí Dev ‚Üí QA, snapshots the full state, and writes a `summary.json` with story status counts and configuration flags.

---

## 2. Operating the A2A Agents

Every pipeline role can run as an A2A service that exposes:

- `/.well-known/agent-card.json` ‚Äì discovery metadata (skills, auth, capabilities).
- `/jsonrpc` ‚Äì JSON-RPC 2.0 endpoint implementing the `message/send` method.
- `/health` ‚Äì readiness probe.

### Starting the agent mesh

```bash
# Start each agent in its own terminal (blocking commands)
python scripts/run_ba.py serve
python scripts/run_product_owner.py serve
python scripts/run_architect.py serve
python scripts/run_dev.py serve
python scripts/run_qa.py serve
python scripts/run_orchestrator.py serve

# Trigger a full run via JSON-RPC (from another shell)
python scripts/run_orchestrator.py execute --concept "Mid-market social tagging assistant"

# Or call individual skills programmatically
python - <<'PY'
from a2a.client import A2AClient
client = A2AClient()
print(client.fetch_card("business_analyst"))
print(client.send_task("business_analyst", "extract_requirements", {"concept": "Demo app"}))
PY
```

Agent endpoints, ports, and flags live in `config/a2a_agents.yaml`. Adjust them before launching services. Each CLI also supports direct invocation (e.g., `python scripts/run_architect.py run --concept ...`) to keep the legacy workflow available.

---

## 3. Release Loop Lifecycle

1. **Concept intake** ‚Äì BA converts the concept into requirements (`planning/requirements.yaml`).
2. **Architecture & stories** ‚Äì Architect creates PRD, architecture, epics, stories, and tasks.
3. **Development** ‚Äì Dev agent iterates through stories, updating `project/` code and tests.
4. **Quality gate** ‚Äì QA executes pytest/Jest suites and enforces TDD:
   - Missing tests ‚Üí `blocked_no_tests`
   - Test failures ‚Üí `in_review` + auto Architect adjustment (`ARCHITECT_INTERVENTION=1`)
   - Severity-based force approval allowed after ‚â•3 retries on P1/P0 stories
5. **Snapshot** ‚Äì `artifacts/iterations/<iteration>/` stores planning, project, and `summary.json`.
6. **Follow-up** ‚Äì Use `make loop MAX_LOOPS=1` to retry blocked stories with the refined criteria.

---

## 4. Anatomy of a Snapshot

```
artifacts/iterations/<iteration-name>/
‚îú‚îÄ‚îÄ planning/
‚îÇ   ‚îú‚îÄ‚îÄ requirements.yaml
‚îÇ   ‚îú‚îÄ‚îÄ prd.yaml
‚îÇ   ‚îú‚îÄ‚îÄ architecture.yaml
‚îÇ   ‚îú‚îÄ‚îÄ epics.yaml
‚îÇ   ‚îú‚îÄ‚îÄ stories.yaml
‚îÇ   ‚îî‚îÄ‚îÄ tasks.csv
‚îú‚îÄ‚îÄ project/
‚îÇ   ‚îú‚îÄ‚îÄ backend-fastapi/
‚îÇ   ‚îî‚îÄ‚îÄ web-express/
‚îî‚îÄ‚îÄ summary.json
```

`summary.json` includes:
- Concept used, timestamps, loop count, QA strictness.
- Counts of stories by status (`done`, `blocked`, `pending`).
- Lists of story IDs per status for quick inspection.

---

## 5. Supporting Infrastructure

### 5.1 Core Pipeline Strengths (Quick View)

| Feature | Summary |
| ------- | ------- |
| **Integral TDD** | Tests are mandatory per story; QA blocks missing suites when `ALLOW_NO_TESTS=0`. |
| **Intelligent QA** | Severity-aware classification, automated architect interventions, and selective force approval. |
| **Auto-Retry + Dependencies** | Stories in `waiting` state unlock when prerequisites finish; Dev‚ÜíQA loops run via `make loop`. |
| **Cross-Stack Support** | Backend (FastAPI), web (Express.js), and new modules (React Native, services) supported through skeletons. |

### 5.2 Project Defaults Skeleton

`project-defaults/` provides a minimal scaffold copied into `project/` whenever missing:
- `backend-fastapi/app/__init__.py` ensures imports like `from app.foo import ...` always work.
- Placeholder test packages and `.gitkeep` files for web assets.
- Stub modules for FastAPI/Pydantic (optional) so QA runs even if dependencies are offline.

`common.ensure_dirs()` clones these defaults without overwriting existing files, meaning release loops always start from a consistent baseline after cleanup.

### 5.3 Multi-Stack Extensibility & Providers

- Roles are configured in `config.yaml`; each loop release can target Ollama, OpenAI, or Codex CLI per agent.
- Extending to new stacks (e.g., mobile apps, additional services) is as simple as adding a skeleton under `project-defaults/`‚Äîrelease loops will copy the structure automatically.
- `scripts/llm.py` handles provider selection per role, logging raw interactions under `artifacts/<role>/last_raw.txt`.
- Mix and match local (Ollama) or paid APIs (OpenAI, Claude Code, Codex CLI, etc.) within the same release; each role can target a different provider without code changes.

### 5.4 Architect Complexity Tiers

- The Architect agent inspects `planning/requirements.yaml` and chooses between three prompt tiers:
  - **Simple** ‚Äì 3‚Äë6 broad stories, high developer autonomy; triggered by lightweight/MVP requirements.
  - **Medium** ‚Äì Default backlog size (approx. 5‚Äë12 stories) with balanced detail.
  - **Corporate** ‚Äì 10‚Äë18 highly specified stories covering integrations, compliance, and non-functional requirements.
- Selection is primarily driven by an LLM classifier fed with the requirements text; a lightweight word-count fallback keeps the system resilient when the classifier is unavailable.
- Override manually when needed with `FORCE_ARCHITECT_TIER=<simple|medium|corporate> make plan`.
- The chosen tier is exposed in console logs (`Complexity tier selected: ...`) and passed to the LLM so outputs scale in detail automatically.

### 5.5 Token Tracking Policy

- Log the token cost (or mark as `N/A` when unavailable) for every significant command or AI interaction.
- Append entries to `TOKEN_USAGE.md`, including UTC timestamp, action description, and estimated tokens.

### 5.6 A2A Agent Configuration

- Agent endpoints and capabilities are declared in `config/a2a_agents.yaml`.
- Role launchers (`scripts/run_*_agent.py`) expose A2A-compliant FastAPI services using the helpers under `a2a/`.
- Business Analyst, Product Owner, Architect, Developer, and QA handlers delegate to the existing role workflows; the Orchestrator skill calls them sequentially via `A2AClient`.

---

## 6. Getting Started (Strict Release)

1. **Install dependencies**
   ```bash
   make setup
   ```
2. **Set providers/models**
   ```bash
   make set-role role=architect provider=codex_cli model="gpt-5-codex"
   make set-role role=dev provider=ollama model="mistral:7b-instruct"
   ```
3. **Run a strict loop release**
   ```bash
   make iteration CONCEPT="CoffeeClub Inventory & Ordering" LOOPS=2 ALLOW_NO_TESTS=0
   ```
4. **Inspect results**
   ```bash
   cat artifacts/iterations/<iteration>/summary.json
   tree artifacts/iterations/<iteration>/
   ```
5. **Retry blocked stories**
   ```bash
   make loop MAX_LOOPS=1
   ```

---

## 7. Advanced Controls

| Flag | Purpose |
| ---- | ------- |
| `ALLOW_NO_TESTS` | TDD strictness (0 = strict, 1 = relaxed) |
| `ARCHITECT_INTERVENTION` | Enables auto story refinements when QA fails |
| `STRICT_TDD` | Forces Architect to embed additional TDD requirements |
| `LOOP_MODE=dev_only` | Skip QA for exploratory coding loops |
| `SKIP_BA` / `SKIP_PLAN` | Reuse existing requirements/stories for incremental releases |

Use these flags in `make iteration` or directly in `make loop` for lower-level control.

---

## 8. Reference Commands

```bash
# One-off actions
make ba                          # BA ‚Üí requirements
make po                          # Product Owner ‚Üí vision + alignment review
make plan                        # Architect ‚Üí PRD, epics, stories, tasks
make dev STORY=S1                # Dev implements a specific story
make qa QA_RUN_TESTS=1           # Run QA with tests
make clean                       # Purge artifacts/ (FLUSH=1 also wipes planning/ and project/)
python scripts/run_ba.py serve             # Start Business Analyst agent service
python scripts/run_product_owner.py serve  # Start Product Owner agent service
python scripts/run_architect.py serve      # Start Architect agent service
python scripts/run_dev.py serve            # Start Developer agent service
python scripts/run_qa.py serve             # Start QA agent service
python scripts/run_orchestrator.py serve   # Start Orchestrator agent service

# Orchestration
make loop MAX_LOOPS=10           # Dev‚ÜîQA loop (includes Architect adjustments)
make iteration CONCEPT="..."     # Full loop release with snapshot

# Utilities
./.venv/bin/python scripts/fix_stories.py    # Normalize planning/stories.yaml
./.venv/bin/python scripts/reopen_stories.py # Reset stories to todo
make show-config                             # Inspect resolved provider/model per role
```

---

## 9. Proven Outcome

Loop releases have already generated:
- A full e-commerce platform (auth, catalog, cart, checkout) across 15 stories.
- >200 automated tests validated by QA in strict mode.
- Zero manual coding once the concept is defined.

---

## 10. Conclusion

Treat each loop release as a self-contained product increment: enter a concept, run `make iteration`, and receive code, tests, and documentation. The workflow is **simple to drive**, **powerful in coverage**, and **extensible to any stack or environment**‚Äîfrom hobby experiments to enterprise delivery. The AGNOSTIC AI PIPELINE turns this release cadence into a repeatable process that scales while maintaining audit-ready artifacts. üöÄ
